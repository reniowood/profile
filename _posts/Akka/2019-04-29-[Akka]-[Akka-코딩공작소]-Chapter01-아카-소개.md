---
layout: post
title: "[Akka 코딩공작소] Chatper 1. 아카 소개"
categories: Kafka
---

## 아카란 무엇인가

아카는 동시/분산 애플리케이션을 코딩하는 방식 중 하나인 액터 프로그래밍 모델을 제공한다.

## 액터: 간략한 정리

아카는 액터를 중심으로 한다.

액터는 설정과 메시지 브로커가 필요 없는 메시지 큐와 비슷하다.

메시지는 불변이다.

액터는 한 번의 하나의 메시지를 받을 수 있으며, 메시지를 받기 전에는 아무 것도 하지 않는다.

액터는 다른 액터에게 메시지를 보낼 수 있다.

액터는 모든 것을 비동기적으로 실행한다.

## 확장성에 대한 두 가지 접근 방법: 예제 준비하기

예제: 업무용 채팅 애플리케이션을 수많은 서버로 확장

전통적인 접근 방법과 아카의 접근 방법 비교

- 전통적인 접근 방법
  - 동시성이나 상태 변경을 데이터베이스에 의존하며, 모든 예외를 처리한다.
- 아카의 접근 방법
  - 메시지를 주고 받는 액터를 사용하고, 상태를 공유하지 않으며, 문제 발생한 부분만 격리한다.

프로젝트을 어렵게 만드는 두 가지: 복잡성, 경직도

## 전통적인 규모 확장

시작으로 간단하게 인메모리 서버를 구성한다.

### 전통적인 규모 확장과 내구성: 모든 것을 데이터베이스에 저장

데이터 모델을 데이터베이스에 저장해 상태가 없는 서버를 만들고, 객체는 데이터베이스에서 DAO를 통해 가져온다.

이제는 데이터베이스 서버나 네트워크 문제, 동시성과 관련된 문제를 해결해야 한다. 두 가지 프로그래밍 모델을 사용하게 되어 복잡도가 증가한다.

### 전통적인 규모 확장과 상호 작용: 폴링

서비스 처리 시간의 대부분은 데이터베이스와의 통신에 쓰인다.

사용자에게 실시간으로 정보를 전달하기 위해 데이터베이스를 폴링하고, 사용자로부터 받은 메시지를 메시지 큐를 이용해 데이터베이스에 집어넣기 시작한다.

데이터베이스의 부하가 늘어나고 애플리케이션의 복잡도가 증가한다.

### 전통적인 규모 확장과 상호 작용: 웹 서비스

다른 서비스의 API를 사용하기 시작하면 다른 서비스의 실패에 큰 영향을 받는다.

데이터베이스 접근 사이에 API를 호출하게 되면 데이터베이스 자원을 더 오래 붙들고 있어 문제가 생긴다.

이런 접근 방식은 규모 확장성이 좋지 않다.

## 아카를 사용한 규모 확장

### 아카를 사용한 규모 확장과 내구성: 메시지 송수신

메시지가 추가될 때마다 데이터베이스 로그에 보낸다. 웹 서버를 시작할 때마다 데이터베이스에서 다시 로그를 불러와 데이터를 재구성한다.

- 변경 사항을 이벤트의 시퀀스로 유지한다
  - 저널이라고 부르는 데이터베이스에 이벤트의 시퀀스를 보관하고, 추후에 발생했던 이벤트를 리플레이한다.
- 데이터 전파하기: 대화의 공유
  - 데이터의 양이 많아지면 어디에 어떤 데이터가 있는지를 추적할 수 있는 방법을 사용해 데이터를 여러 서버로 분산시킨다. 이를 샤딩 또는 파티셔닝이라고 한다.

### 아카를 사용한 규모 확장과 상호 작용: 푸시 메시지

특정 이벤트가 발생하면 발행-구독 메커니즘을 이용해 다른 컴포넌트에 전달한다. 사용자에게 푸시가 필요한 이벤트 메시지를 받으면 푸시하면 된다.

### 아카를 사용한 규모 확장과 실패: 비동기 디커플링

이벤트 기반 접근 방법을 이용하면 한 컴포넌트가 중단되어도 다른 컴포넌트는 계속해서 작동한다.

- 이는 컴포넌트 사이의 의존관계를 최소화한다.
- 시간상으로 더 느슨하게 연결된다.
- 공간상으로도 더 느슨하게 연결된다.

### 아카의 접근 방법: 메시지 송신과 수신

아카는 서로 다른 곳의 액터를 사용하고, 이벤트의 순서를 지킬 수 있게 하기 위해 다양한 기능을 제공한다.

액터를 모니터링 하다가 문제가 생기면 컴포넌트를 재시작하거나 전체 애플리케이션을 중단시킬 수도 있다.

## 액터: 한 가지 프로그래밍 모델로 수직/수평 확장을 동시에 할 수 있음

병렬성은 프로세스를 동시에 실행하는 것에 관한 문제인 반면, 동시성은 동시에 기능할 수 있는 프로세스를 정의하는 데 관심이 있다.

여기서는 CPU 수나 서버의 수와 관계없이 동작하는 동시성을 추구한다.

### 비동기 모델

애플리케이션의 규모를 키우려 한다면 비동기적으로 필요한 일을 수행해야 한다.

### 액터 연산

액터는 생성, 송신, 상태 변화, 감독이라는 네 가지 비동기 연산을 제공하는 경량 프로세스다.

- 송신
  - 액터가 다른 액터와 의사소통하기 위한 유일한 방법은 메시지를 송신하는 방법이다.
  - 액터는 내부 상태에 대한 외부 접근을 허용하지 않는다.
  - 메시지 송신은 항상 비동기적이며, 송신한 후에는 확인하지 않는다.
  - 메시지는 변경 불가능해야 한다.
  - 송신 액터와 수신 액터 사이에는 메시지의 순서가 유지된다.
- 생성
  - 액터는 다른 액터를 생성할 수 있다. 이를 통해 액터의 계층 구조를 만들어낸다.
- 상태 변화
  - 액터는 한 번의 하나의 메시지만 받는다. 이를 통해 액터의 상태를 관리하고 변화시킨다.
- 감독
  - 액터는 자신이 만든 다른 액터를 감독해야 한다.
  - 슈퍼바이저 액터는 시스템의 컴포넌트가 실패했을 때 해야 할 일을 결정한다.

## 아카 액터

### 액터 시스템

모든 아카 애플리케이션은 아카가 제공하는 ActorSystem을 만든다. 이 액터 시스템이 최상위 액터를 만들 수 있다.

ActorSystem은 아카 확장을 통해 다양한 기능을 지원한다.

ActorSystem은 만들어진 액터 자체를 반환하지 않고 액터 주소(ActorRef)를 반환한다. 액터에게 메시지를 보내려면 ActorRef를 사용한다.

ActorPath를 이용해 액터 시스템에서 액터를 찾는다. 모든 액터는 이름이 있으며, 같은 계층 내에서 유일해야 한다.

### ActorRef, 우편함, 액터

모든 액터에는 큐와 비슷한 우편함이 있다. ActorRef에 보내진 메시지는 우편함에 저장되며, 액터는 한 번에 하나씩 우편함에 도착한 순서대로 메시지를 처리한다.

### 디스패처

디스패처가 우편함에 있는 메시지를 액터에게 푸시한다.

디스패처는 메시지를 전달할 때 사용할 스레딩 모델을 결정한다.

### 액터와 네트워크

ActorRef는 근본적으로 액터의 주소이므로, 주소를 실제 액터와 연관시키는 방법만 바꾸면 전체 애플리케이션의 규모를 확장할 수 있다.
